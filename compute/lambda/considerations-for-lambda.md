---
description: 'AWS Lambda instance lifecycle: Creation to retirement'
---

# Considerations for Lambda

**1. Creation and setup**

This initial phase involves defining the function's core purpose and establishing its foundational elements.

<table data-header-hidden data-full-width="true"><thead><tr><th>Consideration </th><th>Pertinent AWS Setting</th></tr></thead><tbody><tr><td>IAM Execution Role (Least Privilege)</td><td><p><strong>Configuration > Permissions > Execution role</strong></p><p><br>Use a specific IAM role for the function and ensure its policy grants only the minimum necessary permissions. For example, use policies that grant <code>s3:GetObject</code> on a specific bucket rather than <code>s3:*</code> on all buckets.</p></td></tr><tr><td>Runtime Selection</td><td><p><strong>Basic information > Runtime</strong></p><p><br>Choose the programming language for your function's code. This can impact cold start times and performance. Common options are Node.js, Python, Java, and Go.</p></td></tr><tr><td>Architecture Selection</td><td><p><strong>Configuration > General configuration > Architecture</strong></p><p><br>Select either <code>x86_64</code> or <code>arm64</code> (AWS Graviton2). ARM-based <code>arm64</code> is often more cost-effective for a given performance level.</p></td></tr><tr><td>Configure Lambda Layers</td><td><p><strong>Configuration > Layers</strong></p><p><br>Add layers to include shared code and dependencies, which keeps your function's deployment package smaller. Layers also allow you to update dependencies independently from your function code.</p></td></tr><tr><td>Secure Secrets</td><td><p><strong>Configuration > Environment variables</strong></p><p><br>Do not store sensitive data like API keys or database credentials directly in environment variables. Instead, use AWS Secrets Manager or Parameter Store and grant your function permissions to read those secrets.</p></td></tr><tr><td>Set Environment Variables</td><td><p><strong>Configuration > Environment variables</strong></p><p><br>Store non-sensitive configuration data (e.g., database endpoint, log level) here so you can change it without altering your function's code.</p></td></tr></tbody></table>

**2. Deployment**

This phase focuses on how you package, publish, and manage different versions of your function.&#x20;

<table data-header-hidden data-full-width="true"><thead><tr><th>Consideration </th><th>Pertinent AWS Setting</th></tr></thead><tbody><tr><td>Function Versioning</td><td><p><strong>Actions > Publish new version</strong></p><p><br>Publish a version of your function after each successful code deployment. This creates an immutable snapshot of the code and configuration. Versions are critical for stability and rollbacks.</p></td></tr><tr><td>Alias Management</td><td><p><strong>Configuration > Aliases</strong></p><p><br>Use aliases (e.g., <code>$LATEST</code>, <code>PROD</code>, <code>BETA</code>) to point to specific versions of your function. This allows you to update the alias to a new version without changing the trigger configuration.</p></td></tr><tr><td>Safe Deployment</td><td><p><strong>Configuration > Deployment preference (part of aliases)</strong></p><p><br>Integrate with AWS CodeDeploy for more sophisticated deployment strategies, such as canary or linear rollouts, which allow you to shift traffic to a new version gradually.</p></td></tr></tbody></table>

**3. Usage and execution**

This stage covers optimizing your function for its runtime environment to ensure performance and cost-efficiency.&#x20;

<table data-header-hidden data-full-width="true"><thead><tr><th>Consideration </th><th>Pertinent AWS Setting</th></tr></thead><tbody><tr><td>Memory and Performance</td><td><p><strong>Configuration > General configuration > Memory</strong></p><p><br>Adjust your function's memory. This is the primary knob for controlling performance, as more memory also gives you proportionally more CPU and network bandwidth.</p></td></tr><tr><td>Set Timeout</td><td><p><strong>Configuration > General configuration > Timeout</strong></p><p><br>Configure the maximum execution time for your function. Set this to the lowest value that accommodates your task to avoid unnecessary charges for frozen or long-running invocations.</p></td></tr><tr><td>Control Concurrency</td><td><p><strong>Configuration > Concurrency</strong></p><p><br>Reserved concurrency: Set a limit on the number of simultaneous executions for a function to prevent it from consuming all available account concurrency.<br>Provisioned concurrency: Pre-initialize execution environments for functions that require low-latency responses by avoiding cold starts.</p></td></tr><tr><td>VPC Integration</td><td><p><strong>Configuration > VPC</strong></p><p><br>Attach your function to a Virtual Private Cloud (VPC) if it needs to access resources within one (e.g., an Amazon RDS database). Use private subnets and a NAT gateway for internet access.</p></td></tr><tr><td>Optimize Cold Starts</td><td><p><strong>(No specific setting, but good practice)</strong></p><p><br>Initialize heavy resources (like database connections or SDK clients) outside the main handler function. The Lambda service reuses execution environments for subsequent invocations, keeping these resources warm.</p></td></tr></tbody></table>

**4. Monitoring and error handling**

In this phase, you focus on observability to ensure the reliability and health of your functions.&#x20;

<table data-header-hidden data-full-width="true"><thead><tr><th>Consideration </th><th>Pertinent AWS Setting</th></tr></thead><tbody><tr><td>Enable Structured Logging</td><td><p><strong>Configuration > Monitoring and operations tools > Logging options > Log format</strong></p><p><br>Choose a format like <code>JSON</code> for your logs. This makes parsing and searching logs in CloudWatch easier and more efficient.</p></td></tr><tr><td>Set Log Level</td><td><p><strong>Configuration > Monitoring and operations tools > Logging options > Log level</strong></p><p><br>Choose a log level (e.g., <code>INFO</code>, <code>DEBUG</code>) to control the verbosity of logs sent to CloudWatch.</p></td></tr><tr><td>Configure Error Handling (Asynchronous)</td><td><p><strong>Configuration > Asynchronous invocation > Dead-letter queue</strong></p><p><br>For asynchronous invocations, specify a Dead-Letter Queue (DLQ) using Amazon SQS or SNS. Failed events will be sent to the DLQ after retry attempts fail, preventing data loss.</p></td></tr><tr><td>Enable X-Ray Tracing</td><td><p><strong>Configuration > Monitoring and operations tools > Enable active tracing</strong><br></p><p>Enable AWS X-Ray to trace requests as they flow through your function and other services, providing detailed performance and dependency analysis.</p></td></tr><tr><td>Set CloudWatch Alarms</td><td><p><strong>(CloudWatch service)</strong></p><p><br>Create CloudWatch alarms on key Lambda metrics (e.g., <code>Errors</code>, <code>Throttles</code>, <code>Duration</code>). This allows you to be notified of operational issues.</p></td></tr></tbody></table>

**5. Optimization and maintenance**

This final phase involves ongoing refinement of your function and its resources.

<table data-header-hidden data-full-width="true"><thead><tr><th>Consideration</th><th>Pertinent AWS Setting</th></tr></thead><tbody><tr><td>Manage Log Retention</td><td><p><strong>(CloudWatch service)</strong></p><p><br>Within the CloudWatch log group for your function, set a retention policy to delete old logs automatically and control costs.</p></td></tr><tr><td>Automate Lifecycle Management</td><td><p><strong>(AWS SAM or CloudFormation)</strong></p><p><br>Use tools like the AWS Serverless Application Model (SAM) to define your function's configuration in a template. This allows you to manage versions, aliases, and other settings through a consistent and repeatable process.</p></td></tr><tr><td>Retire Unused Resources</td><td><p><strong>(Console or Infrastructure as Code)</strong></p><p><br>Delete old function versions, layers, IAM roles, and log groups that are no longer needed to reduce clutter and costs.</p></td></tr></tbody></table>
